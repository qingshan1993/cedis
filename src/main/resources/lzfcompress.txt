1. Introduction1.1. MotivationsProgram analysis, generation and transformation are useful techniques thatcan be used in many situations:• Program analysis, which can range from a simple syntaxic parsing to afull semantic analysis, can be used to find potential bugs in applications,to detect unused code, to reverse engineer code, etc.• Program generation is used in compilers. This include traditional com�pilers, but also stub or skeleton compilers used for distributed program�ming, Just in Time compilers, etc.• Program transformation can be used to optimize or obfuscate programs,to insert debugging or performance monitoring code into applications,for aspect oriented programming, etc.All these techniques can be used for any programming language, but this ismore or less easy to do, depending on the language. In the case of Javathey can be used on Java source code or on compiled Java classes. One ofthe advantages of working on compiled classes is that, obviously, the sourcecode is not needed. Program transformations can therefore be used on anyapplications, including closed source and commercial ones. Another advantageof working on compiled code is that it becomes possible to analyze, generate ortransform classes at runtime, just before they are loaded into the Java VirtualMachine (generating and compiling source code at runtime is possible, butthis is really slow and requires a full Java compiler). The advantage is thattools such as stub compilers or aspect weavers become transparent to users.Due to the many possible usages of program analysis, generation and transfor�mation techniques, many tools to analyze, generate and transform programshave been implemented, for many languages, Java included. ASM is one ofthese tools for the Java language, designed for runtime – but also offline – class11. Introductiongeneration and transformation. The ASM1library was therefore designed towork on compiled Java classes. It was also designed to be as fast and as smallas possible. Being as fast as possible is important in order not to slow downtoo much the applications that use ASM at runtime, for dynamic class gener�ation or transformation. And being as small as possible is important in orderto be used in memory constrained environments, and to avoid bloating thesize of small applications or libraries using ASM.ASM is not the only tool for generating and transforming compiled Javaclasses, but it is one of the most recent and efficient. It can be downloadedfrom http://asm.objectweb.org. Its main advantages are the following:• It has a simple, well designed and modular API that is easy to use.• It is well documented and has an associated Eclipse plugin.• It provides support for the latest Java version, Java 7.• It is small, fast, and very robust.• Its large user community can provide support for new users.• Its open source license allows you to use it in almost any way you want.1.2. Overview1.2.1. ScopeThe goal of the ASM library is to generate, transform and analyze compiledJava classes, represented as byte arrays (as they are stored on disk and loadedin the Java Virtual Machine). For this purpose ASM provides tools to read,write and transform such byte arrays by using higher level concepts than bytes,such as numeric constants, strings, Java identifiers, Java types, Java classstructure elements, etc. Note that the scope of the ASM library is strictlylimited to reading, writing, transforming and analyzing classes. In particularthe class loading process is out of scope.1the ASM name does not mean anything: it is just a reference to the __asm__ keyword inC, which allows some functions to be implemented in assembly language.21.2. Overview1.2.2. ModelThe ASM library provides two APIs for generating and transforming compiledclasses: the core API provides an event based representation of classes, whilethe tree API provides an object based representation.With the event based model a class is represented with a sequence of events,each event representing an element of the class, such as its header, a field, amethod declaration, an instruction, etc. The event based API defines the setof possible events and the order in which they must occur, and provides a classparser that generates one event per element that is parsed, as well as a classwriter that generates compiled classes from sequences of such events.With the object based model a class is represented with a tree of objects, eachobject representing a part of the class, such as the class itself, a field, a method,an instruction, etc. and each object having references to the objects thatrepresent its constituents. The object based API provides a way to converta sequence of events representing a class to the object tree representing thesame class and, vice versa, to convert an object tree to the equivalent eventsequence. In other words the object based API is built on top of the eventbased API.These two APIs can be compared to the Simple API for XML (SAX) andDocument Object Model (DOM) APIs for XML documents: the event basedAPI is similar to SAX, while the object based API is similar to DOM. Theobject based API is built on top of the event based one, like DOM can beprovided on top of SAX.ASM provides both APIs because there is no best API. Indeed each API hasits own advantages and drawbacks:• The event based API is faster and requires less memory than the objectbased API, since there is no need to create and store in memory a treeof objects representing the class (the same difference also exists betweenSAX and DOM).• However implementing class transformations can be more difficult withthe event based API, since only one element of the class is availableat any given time (the element that corresponds to the current event),while the whole class is available in memory with the object based API.Note that the two APIs manage only one class at a time, and independentlyof the others: no information about the class hierarchy is maintained, and if a31. Introductionclass transformation affects other classes, it is up to the user to modify theseother classes.1.2.3. ArchitectureASM applications have a strong architectural aspect. Indeed the event basedAPI is organized around event producers (the class parser), event consumers(the class writer) and various predefined event filters, to which user definedproducers, consumers and filters can be added. Using this API is therefore atwo step process:• assembling event producer, filter and consumer components into possiblycomplex architectures,• and then starting the event producers to run the generation or transfor�mation process.The object based API also has an architectural aspect: indeed class generatoror transformer components that operate on object trees can be composed, thelinks between them representing the order of transformations.Although most component architectures in typical ASM applications are quitesimple, it is possible to imagine complex architectures like the following, wherearrows represent event based or object based communications between classparsers, writers or transformers, with possible conversions between the eventbased and object based representations anywhere in the chain:1.3. OrganizationThe ASM library is organized in several packages that are distributed in severaljar files:41.3. Organization• the org.objectweb.asm and org.objectweb.asm.signature packagesdefine the event based API and provide the class parser and writer com�ponents. They are contained in the asm.jar archive.• the org.objectweb.asm.util package, in the asm-util.jar archive,provides various tools based on the core API that can be used duringthe development and debuging of ASM applications.• the org.objectweb.asm.commons package provides several useful pre�defined class transformers, mostly based on the core API. It is containedin the asm-commons.jar archive.• the org.objectweb.asm.tree package, in the asm-tree.jar archive,defines the object based API, and provides tools to convert between theevent based and the object based representations.• the org.objectweb.asm.tree.analysis package provides a class anal�ysis framework and several predefined class analyzers, based on the treeAPI. It is contained in the asm-analysis.jar archive.This document is organized in two parts. The first part covers the core API,i.e. the asm, asm-util and asm-commons archives. The second part covers thetree API, i.e. the asm-tree and asm-analysis archives. Each part contains atleast one chapter for the API related to classes, one chapter for the API relatedto methods, and one chapter for the API related to annotations, generic types,etc. Each chapter covers the programming interfaces as well as the related toolsand predefined components. The source code of all the examples is availableon the ASM web site.This organization makes it easier to introduce class file features progressively,but sometimes required to spread the presentation of a single ASM class in sev�eral sections. It is therefore recommanded to read this document in sequentialorder. For a reference guide about the ASM API, please use the Javadoc.Typographic conventionsItalic is used for emphasizing elements in a sentence.Constant width is used for code fragments.Bold constant width is used for emphasizing code elements.Italic constant width is used for variable parts in code and for labels.51. Introduction1.4. AcknowledgmentsI would like to thank François Horn for his valuable remarks during the elabo�ration of this document, which greatly improved its structure and readability.6Part I.Core API72. ClassesThis chapter explains how to generate and transform compiled Java classeswith the core ASM API. It starts with a presentation of compiled classesand then presents the corresponding ASM interfaces, components and tools togenerate and transform them, with many illustrative examples. The contentof methods, annotations and generics are explained in the next chapters.2.1. Structure2.1.1. OverviewThe overall structure of a compiled class is quite simple. Indeed, unlike na�tively compiled applications, a compiled class retains the structural informa�tion and almost all the symbols from the source code. In fact a compiled classcontains:• A section describing the modifiers (such as public or private), thename, the super class, the interfaces and the annotations of the class.• One section per field declared in this class. Each section describes themodifiers, the name, the type and the annotations of a field.• One section per method and constructor declared in this class. Each sec�tion describes the modifiers, the name, the return and parameter types,and the annotations of a method. It also contains the compiled code ofthe method, in the form of a sequence of Java bytecode instructions.There are however some differences between source and compiled classes:• A compiled class describes only one class, while a source file can containseveral classes. For instance a source file describing a class with one innerclass is compiled in two class files: one for the main class and one for theinner class. However the main class file contains references to its innerclasses, and inner classes defined inside methods contain a reference totheir enclosing method.92. Classes• A compiled class does not contain comments, of course, but can containclass, field, method and code attributes that can be used to associateadditional information to these elements. Since the introduction of an�notations in Java 5, which can be used for the same purpose, attributeshave become mostly useless.• A compiled class does not contain a package and import section, so alltype names must be fully qualified.Another very important structural difference is that a compiled class containsa constant pool section. This pool is an array containing all the numeric, stringand type constants that appear in the class. These constants are defined onlyonce, in the constant pool section, and are referenced by their index in all othersections of the class file. Hopefully ASM hides all the details related to theconstant pool, so you will not have to bother about it. Figure 2.1 summarizesthe overall structure of a compiled class. The exact structure is described inthe Java Virtual Machine Specification, section 4.Modifiers, name, super class, interfacesConstant pool: numeric, string and type constantsSource file name (optional)Enclosing class referenceAnnotation*Attribute*Inner class* NameField* Modifiers, name, typeAnnotation*Attribute*Method* Modifiers, name, return and parameter typesAnnotation*Attribute*Compiled codeFigure 2.1.: Overall structure of a compiled class (* means zero or more)Another important difference is that Java types are represented differently incompiled and source classes. The next sections explain their representation incompiled classes.102.1. Structure2.1.2. Internal namesIn many situations a type is constrained to be a class or interface type. Forinstance the super class of a class, the interfaces implemented by a class, orthe exceptions thrown by a method cannot be primitive types or array types,and are necessarily class or interface types. These types are represented incompiled classes with internal names. The internal name of a class is just thefully qualified name of this class, where dots are replaced with slashes. Forexample the internal name of String is java/lang/String.2.1.3. Type descriptorsInternal names are used only for types that are constrained to be class orinterface types. In all other situations, such as field types, Java types arerepresented in compiled classes with type descriptors (see Figure 2.2).Java type Type descriptorboolean Zchar Cbyte Bshort Sint Ifloat Flong Jdouble DObject Ljava/lang/Object;int[] [IObject[][] [[Ljava/lang/Object;Figure 2.2.: Type descriptors of some Java typesThe descriptors of the primitive types are single characters: Z for boolean, Cfor char, B for byte, S for short, I for int, F for float, J for long and Dfor double. The descriptor of a class type is the internal name of this class,preceded by L and followed by a semicolon. For instance the type descriptorof String is Ljava/lang/String;. Finally the descriptor of an array type isa square bracket followed by the descriptor of the array element type.112. Classes2.1.4. Method descriptorsA method descriptor is a list of type descriptors that describe the parametertypes and the return type of a method, in a single string. A method descriptorstarts with a left parenthesis, followed by the type descriptors of each formalparameter, followed by a right parenthesis, followed by the type descriptor ofthe return type, or V if the method returns void (a method descriptor doesnot contain the method’s name or the argument names).Method declaration in source file Method descriptorvoid m(int i, float f) (IF)Vint m(Object o) (Ljava/lang/Object;)Iint[] m(int i, String s) (ILjava/lang/String;)[IObject m(int[] i) ([I)Ljava/lang/Object;Figure 2.3.: Sample method descriptorsOnce you know how type descriptors work, understanding method descriptorsis easy. For instance (I)I describes a method that takes one argument of typeint, and returns an int. Figure 2.3 gives several method descriptor examples.2.2. Interfaces and components2.2.1. PresentationThe ASM API for generating and transforming compiled classes is based onthe ClassVisitor abstract class (see Figure 2.4). Each method in this classcorresponds to the class file structure section of the same name (see Figure2.1). Simple sections are visited with a single method call whose argumentsdescribe their content, and which returns void. Sections whose content can beof arbitrary length and complexity are visited with a initial method call thatreturns an auxiliary visitor class. This is the case of the visitAnnotation,visitField and visitMethod methods, which return an AnnotationVisitor, a FieldVisitor and a MethodVisitor respectively.The same principles are used recursively for these auxiliary classes. For ex�ample each method in the FieldVisitor abstract class (see Figure 2.5) corre�sponds to the class file sub structure of the same name, and visitAnnotation122.2. Interfaces and componentspublic abstract class ClassVisitor {public ClassVisitor(int api);public ClassVisitor(int api, ClassVisitor cv);public void visit(int version, int access, String name,String signature, String superName, String[] interfaces);public void visitSource(String source, String debug);public void visitOuterClass(String owner, String name, String desc);AnnotationVisitor visitAnnotation(String desc, boolean visible);public void visitAttribute(Attribute attr);public void visitInnerClass(String name, String outerName,String innerName, int access);public FieldVisitor visitField(int access, String name, String desc,String signature, Object value);public MethodVisitor visitMethod(int access, String name, String desc,String signature, String[] exceptions);void visitEnd();}Figure 2.4.: The ClassVisitor classreturns an auxiliary AnnotationVisitor, as in ClassVisitor. The creationand usage of these auxiliary visitors is explained in the next chapters: in�deed this chapter is restricted to simple problems that can be solved with theClassVisitor class alone.public abstract class FieldVisitor {public FieldVisitor(int api);public FieldVisitor(int api, FieldVisitor fv);public AnnotationVisitor visitAnnotation(String desc, boolean visible);public void visitAttribute(Attribute attr);public void visitEnd();}Figure 2.5.: The FieldVisitor classThe methods of the ClassVisitor class must be called in the following order,specified in the Javadoc of this class:visit visitSource? visitOuterClass? ( visitAnnotation | visitAttribute )*( visitInnerClass | visitField | visitMethod )*visitEndThis means that visit must be called first, followed by at most one call tovisitSource, followed by at most one call to visitOuterClass, followed by132. Classesany number of calls in any order to visitAnnotation and visitAttribute,followed by any number of calls in any order to visitInnerClass, visitFieldand visitMethod, and terminated by a single call to visitEnd.ASM provides three core components based on the ClassVisitor API togenerate and transform classes:• The ClassReader class parses a compiled class given as a byte array,and calls the corresponding visitXxx methods on the ClassVisitorinstance passed as argument to its accept method. It can be seen as anevent producer.• The ClassWriter class is a subclass of the ClassVisitor abstract classthat builds compiled classes directly in binary form. It produces asoutput a byte array containing the compiled class, which can be retrievedwith the toByteArray method. It can be seen as an event consumer.• The ClassVisitor class delegates all the method calls it receives toanother ClassVisitor instance. It can be seen as an event filter.The next sections show with concrete examples how these components can beused to generate and transform classes.2.2.2. Parsing classesThe only required component to parse an existing class is the ClassReadercomponent. Let’s take an example to illustrate this. Suppose that we wouldlike to print the content of a class, in a similar way as the javap tool. The firststep is to write a subclass of the ClassVisitor class that prints informationabout the classes it visits. Here is a possible, overly simplified implementation:public class ClassPrinter extends ClassVisitor {public ClassPrinter() {super(ASM4);}public void visit(int version, int access, String name,String signature, String superName, String[] interfaces) {System.out.println(name +  extends  + superName +  {);}public void visitSource(String source, String debug) {}public void visitOuterClass(String owner, String name, String desc) {}public AnnotationVisitor visitAnnotation(String desc,boolean visible) {142.2. Interfaces and componentsreturn null;}public void visitAttribute(Attribute attr) {}public void visitInnerClass(String name, String outerName,String innerName, int access) {}public FieldVisitor visitField(int access, String name, String desc,String signature, Object value) {System.out.println(  + desc +   + name);return null;}public MethodVisitor visitMethod(int access, String name,String desc, String signature, String[] exceptions) {System.out.println(  + name + desc);return null;}public void visitEnd() {System.out.println(});} }The second step is to combine this ClassPrinter with a ClassReader component, so that the events produced by the ClassReader are consumed by ourClassPrinter:ClassPrinter cp = new ClassPrinter();ClassReader cr = new ClassReader(java.lang.Runnable);cr.accept(cp, 0);The second line creates a ClassReader to parse the Runnable class. Theaccept method called at the last line parses the Runnable class bytecodeand calls the corresponding ClassVisitor methods on cp. The result is thefollowing output:java/lang/Runnable extends java/lang/Object {run()V}Note that there are several ways to construct a ClassReader instance. Theclass that must be read can be specified by name, as above, or by value, as abyte array or as an InputStream. An input stream to read the content of aclass can be obtained with the ClassLoader’s getResourceAsStream methodwith: